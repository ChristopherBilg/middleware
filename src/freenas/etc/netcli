#!/usr/bin/env python3
#
# Copyright 2020 iXsystems, Inc.
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#####################################################################

import getpass
import os
import platform
import signal
import sys
import subprocess
import time
import traceback

import ipaddress
import ipaddr
import sqlite3

from middlewared.client import Client

from requests.packages.urllib3 import poolmanager
from requests.packages.urllib3.connectionpool import HTTPSConnectionPool

# Only root can run it.
if os.geteuid() != 0:
    exit("This command must be run with root privileges.")

FREENAS_DATA_PATH = "/data"
FREENAS_DB = os.path.join(FREENAS_DATA_PATH, "freenas-v1.db")
IS_LINUX = platform.system().lower() == 'linux'
LAGGTypes = {
    '1': ("FAILOVER", "Failover"),
    '2': ("LACP", "LACP"),
    '3': ("LOADBALANCE", "Load Balance"),
    '4': ("ROUNDROBIN", "Round Robin"),
    '5': ("not_used", 'None'),
}


def _(s):
    return s


def get_nic_choices():

    """
    Helper function to generate a list of all
    detected interfaces.
    """

    choices = []
    try:
        with Client() as c:
            choices = c.call('interface.query')
    except Exception as e:
        print('Failed to obtain list of interfaces with error: \n%s', e)

    return choices


class DjangoModelMeta(type):
    @property
    def objects(cls):
        return DjangoModelManager(cls)


class DjangoModel(metaclass=DjangoModelMeta):
    datastore = NotImplementedError

    def __init__(self, **kwargs):
        self.row = kwargs

    def __getattr__(self, item):
        try:
            return self.row[item]
        except KeyError:
            return None

    def __setattr__(self, key, value):
        if key in ['row']:
            self.__dict__[key] = value
        else:
            self.row[key] = value

    def save(self):
        data = self.row.copy()

        for k, v in data.items():
            if isinstance(v, DjangoModel):
                if v.id is None:
                    v.save()

                data[k] = v.id

        with Client() as c:
            if 'id' in self.row:
                c.call('datastore.update', self.datastore, self.row['id'], data)
            else:
                self.row['id'] = c.call('datastore.insert', self.datastore, data)

    def delete(self):
        with Client() as c:
            c.call('datastore.delete', self.datastore, self.row['id'])


class DjangoModelManager:
    def __init__(self, cls):
        self.cls = cls

    def all(self):
        return self.filter()

    def create(self, **kwargs):
        self.cls(**kwargs).save()

    def filter(self, **kwargs):
        with Client() as c:
            return DjangoModelResultSet([
                self.cls(**row)
                for row in c.call('datastore.query', self.cls.datastore, [[k, '=', v] for k, v in kwargs.items()])
            ])


class DjangoModelResultSet:
    def __init__(self, objects):
        self.objects = objects

    def exists(self):
        return bool(self.objects)

    def __bool__(self):
        return bool(self.objects)

    def __getitem__(self, item):
        return self.objects[item]

    def __iter__(self):
        return iter(self.objects)


def produce_django_model(ds):
    class Model(DjangoModel):
        datastore = ds

    return Model


GlobalConfiguration = produce_django_model("network.globalconfiguration")
StaticRoute = produce_django_model("network.staticroute")
Support = produce_django_model("system.support")


class FailoverIsEnabledException(Exception):
    pass


def ensure_failover_is_disabled():
    with Client() as c:
        if c.call('failover.licensed') and not c.call('failover.config')['disabled']:
            raise FailoverIsEnabledException()


# Custom class to avoid warning about unverified SSL, see #16474
class HTTPSConnectionPoolNoWarn(HTTPSConnectionPool):
    def _validate_conn(self, conn):
        """
        Called right before a request is made, after the socket is created
.
        """
        super(HTTPSConnectionPool, self)._validate_conn(conn)

        # Force connect early to allow us to validate the connection.
        if not getattr(conn, 'sock', None):  # AppEngine might not have  ` .sock`
            conn.connect()


poolmanager.pool_classes_by_scheme['https'] = HTTPSConnectionPoolNoWarn


def prompt(prompt_str, default_value=None):
    """Returns a string that forms a prompt, based on values passed in"""
    if default_value:
        default_str = ' [%s]' % (str(default_value), )
    else:
        default_str = ''
    return (prompt_str + default_str + ':')


def configure_interface_stub(*args):

    retval = configure_interface()

    # only need to reload http service if
    # interface changes occurred
    if retval:
        with Client() as c:
            c.call('service.reload', 'http')

    return retval


def configure_interface():

    # get list of nics
    nics = get_nic_choices()

    # build exclusion list
    exclude = []
    for i in nics:
        if i['type'] == 'LINK_AGGREGATION':
            for j in i['lag_ports']:
                exclude.append(j)

    # sort the nics
    choices = sorted([i['id'] for i in nics if i['id'] not in exclude])

    # this shouldn't happen but check anyway
    if not choices:
        print('No interfaces detected')
        return False

    while True:
        for idx, nic in enumerate(choices, start=1):
            print(f"{idx}) {nic}")

        _input = input("Select an interface (q to quit): ")
        if _input.lower().startswith("q"):
            return False
        if _input.isdigit():
            _input = int(_input)
        else:
            print("Invalid option")
            continue

        if _input in range(1, len(choices) + 1):
            nic = choices[_input - 1]
            break
        else:
            print("Invalid option")
            continue

    # check to see if this interface has already been configured or exists in the db
    iface_configured = []
    try:
        with Client() as c:
            iface_configured = c.call('datastore.query', 'network.interfaces', [('int_interface', '=', nic)])[0]
    except Exception:
        pass

    # we need to delete the interface config from db before we proceed
    if iface_configured:
        while True:
            print("Interface has been previously configured, the current configuration must be deleted before proceeding.")
            _input = input("Delete interface configuration? (y/n): ")
            if _input.lower().startswith("y"):

                print("Deleting interface configuration.")
                try:
                    with Client() as c:
                        c.call('interface.delete', iface_configured['int_interface'])
                        c.call('service.start', 'network')
                        print("Successfully deleted interface configuration.")
                        return True
                except Exception as e:
                    print("Failed deleting interface configuration with error: \n%s", e)
                    # no reason to continue if this fails
                    return False

            elif _input.lower().startswith('n'):
                return False

            else:
                print("Invalid option")
                continue

    # get HA related configuration
    is_enterprise = failover_licensed = failover_node = False
    try:
        with Client() as c:
            is_enterprise = c.call('system.is_enterprise')
            failover_licensed = c.call('failover.licensed')
            failover_node = c.call('failover.node')
    except Exception:
        # this is bad on HA systems but it's safe to say that many other
        # problems are occurring so ignore
        pass

    # DHCPv4/v6 configuration section
    dhcp_options = {}
    _dhcp_input = input("Configure interface for DHCPv4/v6? (y/n): ")
    if _dhcp_input.lower().startswith("y"):
        if failover_licensed:
            print("DHCPv4/v6 is not supported on HA systems.")
            return False
        else:
            dhcp_menu = {
                '1': ('DHCPv4', {'ipv4_dhcp': True}),
                '2': ('DHCPv6', {'ipv6_auto': True}),
                '3': ('DHCPv4 and DHCPv6', {'ipv4_dhcp': True, 'ipv6_auto': True}),
                '4': ('Quit', 'not_used'),
            }
            while True:
                for k, v in dhcp_menu.items():
                    print(f'{k}) {v[0]}')
                _dhcp_option = input(f"Choose an option between 1-{len(dhcp_menu)}: ")
                if _dhcp_option in dhcp_menu.keys():
                    if _dhcp_option == '4':
                        return False
                    else:
                        dhcp_options = dhcp_menu[_dhcp_option][1]
                        break
                else:
                    print("Invalid option")
                    continue

    # interface name section
    _int_name = nic
    while True:
        _change_name = input(f'Change interface name? (default is "{nic}") (y/n): ')
        if _change_name.lower().startswith('y'):
            _new_name = input("New name: ")
            if _new_name.isdigit():
                print("Interface names cannot be numbers.")
                continue
            elif not _new_name.strip():
                print("New name cannot be empty")
                continue
            else:
                _int_name = _new_name
                break
        elif _change_name.lower().startswith('n'):
            break
        elif not _change_name.strip():
            break
        else:
            continue

    # means interface is configured for dhcp
    if dhcp_options:

        # make sure we include the new name
        options = {'name': _int_name}
        options.update(dhcp_options)

        print("Saving interface configuration.")
        try:
            with Client() as c:
                c.call('interface.update', nic, options)
                c.call('service.start', 'network')
                return True
        except Exception as e:
            print("Failed saving interface configuration with error: \n%s", e)
            return False

    ip_menu = {
        '1': "Configure IPv4",
        '2': "Configure IPv6",
        '3': "Quit",
    }
    ip_vers = {'ipv4': False, 'ipv6': False}
    while True:
        # prompt the end-user for IP config
        for k, v in ip_menu.items():
            print(f"{k}) {v}")

        _ip_input = input(f"Choose an option between 1-{len(ip_menu)}: ")
        if _ip_input in ip_menu.keys():
            if _ip_input == '3':
                return False
            elif _ip_input == '1':
                ip_vers['ipv4'] = True
                break
            elif _ip_input == '2':
                ip_vers['ipv6'] = True
                break
        else:
            print("Choose a valid option.")
            continue

    # HA IPv4/v6 section
    if is_enterprise and failover_licensed:
        license_ip_info = {
            'ip_a_nodea': ["PLACEHOLDER", "IP Address (This TrueNAS Controller): "],
            'ip_b_nodea': ["PlACEHOLDER", "IP Address (TrueNAS Controller B): "],
            'ip_a_nodeb': ["PLACEHOLDER", "IP Address (TrueNAS Controller A): "],
            'ip_b_nodeb': ["PlACEHOLDER", "IP Address (This TrueNAS Controller): "],
            'ip_vip': ["PLACEHOLDER", "Virtual IP Address (Failover IP): "],
            'ip_vhid': ["PLACEHOLDER", "VHID: "],
            'ip_crit': ["PLACEHOLDER", "Mark interface critical for failover? (y/n): "],
            'ip_grp': ["PLACEHOLDER", "Failover group id: "],
        }
        if failover_node == 'A':
            license_ip_info.pop('ip_a_nodeb')
            license_ip_info.pop('ip_b_nodeb')
        else:
            license_ip_info.pop('ip_a_nodea')
            license_ip_info.pop('ip_b_nodea')

        for k, v in license_ip_info.items():

            # vhid is only applicable on freebsd
            if k == 'ip_vhid' and not IS_LINUX:
                continue

            # handle IP config
            if k in ('ip_a_node', 'ip_b_node'):
                while True:
                    if ip_vers['ipv4']:
                        print("\nSeveral input formats are supported")
                        print("Example 1 CIDR Notation:")
                        print("    192.168.1.1/24 or 192.168.1.1/255.255.255.0")
                        print("Example 2 IP and Netmask separate:")
                        print("    IP Address: 192.168.1.1")
                        print("    Netmask: 255.255.255.0, /24 or 24\n")
                    elif ip_vers['ipv6']:
                        print("\nSeveral input formats are supported")
                        print("Example 1 CIDR Notation:")
                        print("    2001:db8:aaaa:1111::100/64")
                        print("Example 2 IP and Prefix separate:")
                        print("    IP Address: 2001:db8:aaaa:1111::100")
                        print("    Prefix: /64 or 64\n")

                    # prompt and store the results
                    v[0] = input(v[1])

                    # without a '/' assume only IP was given
                    final = netmask = None
                    if '/' not in v[0] or netmask is None:
                        if ip_vers['ipv4']:
                            netmask = input("Netmask: ")
                        elif ip_vers['ipv6']:
                            netmask = input("Prefix: ")

                        netmask = netmask.split('/')[0]

                    final = v[0] + '/' + netmask if netmask is not None else v[0]

                    try:
                        if ip_vers['ipv4']:
                            v[0] = ipaddress.IPv4Interface(final)
                            break
                        elif ip_vers['ipv6']:
                            v[0] = ipaddress.IPv6Interface(final)
                            break
                    except (ipaddress.AddressValueError, ipaddress.NetmaskValueError):
                        print('Invalid IP address')
                        continue

            # handle VIP config
            vip_netmask = None
            if k == 'ip_vip':
                while True:
                    # VIP netmask/prefix are static
                    if ip_vers['ipv4']:
                        vip_netmask = '32'
                    elif ip_vers['ipv6']:
                        vip_netmask = '128'

                    # make sure to remove netmask/prefix
                    # if it was given to us
                    v[0] = input(v[1])
                    v[0] = v[0].split('/')[0]
                    final = v[0] + '/' + vip_netmask
                    try:
                        if ip_vers['ipv4']:
                            v[0] = ipaddress.IPv4Interface(final)
                            break
                        elif ip_vers['ipv6']:
                            v[0] = ipaddress.IPv6Interface(final)
                            break
                    except (ipaddress.AddressValueError, ipaddress.NetmaskValueError):
                        print('Invalid IP address')
                        continue

            # handle VHID config
            if k == 'ip_vhid':
                while True:
                    v[0] = input(v[1])
                    try:
                        v[0] = int(v[0])
                    except ValueError:
                        print("VHID should be an integer")
                        continue

                    # validate VHID is within range
                    if v[0] < 1 or v[0] > 255:
                        print("VHID should be between 1 and 255")
                        continue
                    else:
                        break

            # handle failover group config
            if k == 'ip_grp':
                while True:
                    v[0] = input(v[1])
                    try:
                        v[0] = int(v[0])
                    except ValueError:
                        print("Failover group should be an integer")
                        continue
                    else:
                        break

            # handle marking it critical for failover
            if k == 'ip_crit':
                while True:
                    v[0] = input(v[1])
                    if v[0].lower().startswith('y'):
                        v[0] = True
                        break
                    elif v[0].lower().startswith('n'):
                        v[0] = False
                        break
                    else:
                        print('Invalid response')
                        continue

    # non-HA ipv4/v6 section
    else:
        non_license_ip_info = {
            'ip': ["PLACEHOLDER", "IP Address: "],
        }
        for k, v in non_license_ip_info.items():

            # handle IP config
            if k == 'ip':
                while True:
                    if ip_vers['ipv4']:
                        print("\nSeveral input formats are supported")
                        print("Example 1 CIDR Notation:")
                        print("    192.168.1.1/24 or 192.168.1.1/255.255.255.0")
                        print("Example 2 IP and Netmask separate:")
                        print("    IP Address: 192.168.1.1")
                        print("    Netmask: 255.255.255.0, /24 or 24\n")
                    elif ip_vers['ipv6']:
                        print("\nSeveral input formats are supported")
                        print("Example 1 CIDR Notation:")
                        print("    2001:db8:aaaa:1111::100/64")
                        print("Example 2 IP and Prefix separate:")
                        print("    IP Address: 2001:db8:aaaa:1111::100")
                        print("    Prefix: /64 or 64\n")

                    # now prompt and store the results
                    v[0] = input(v[1])

                    final = netmask = None
                    if '/' not in v[0] and netmask is None:
                        if ip_vers['ipv4']:
                            netmask = input("Netmask: ")
                        elif ip_vers['ipv6']:
                            netmask = input("Prefix: ")

                        netmask = netmask.split('/')[0]

                    final = v[0] + '/' + netmask if netmask is not None else v[0]

                    try:
                        if ip_vers['ipv4']:
                            v[0] = ipaddress.IPv4Interface(final)
                            break
                        elif ip_vers['ipv6']:
                            v[0] = ipaddress.IPv6Interface(final)
                            break
                    except (ipaddress.AddressValueError, ipaddress.NetmaskValueError):
                        print('Invalid IP address')
                        continue

    # getting here means all static IP address prompts were answered
    # so send it off to middleware API
    print("Saving interface configuration changes.")
    try:

        # set the ip version
        ip_type = 'INET' if not ip_vers['ipv6'] else 'INET6'

        # HA config
        if failover_licensed:
            # build our list of options
            final_options = {
                'name': _int_name,
                'aliases': [],
                'failover_group': None,
                'failover_vhid': None,
                'failover_critical': False,
            }

            aliases = failover_aliases = failover_virtual_aliases = []
            if failover_node == 'A':
                aliases.append({
                    'type': ip_type,
                    'address': str(license_ip_info['ip_a_nodea'][0].ip),
                    'netmask': license_ip_info['ip_a_nodea'][0].netmask._prefix_from_ip_string(str(license_ip_info['ip_a_nodea'][0].netmask)),
                })
                failover_aliases.append({
                    'type': ip_type,
                    'address': str(license_ip_info['ip_b_nodea'][0].ip),
                    'netmask': license_ip_info['ip_a_nodea'][0].netmask._prefix_from_ip_string(str(license_ip_info['ip_a_nodea'][0].netmask)),
                })
                failover_virtual_aliases.append({
                    'type': ip_type,
                    'address': str(license_ip_info['ip_vip'][0].ip),
                    'netmask': license_ip_info['ip_vip'][0].netmask._prefix_from_ip_string(str(license_ip_info['ip_vip'][0].netmask)),
                })
            else:
                aliases.append({
                    'type': ip_type,
                    'address': str(license_ip_info['ip_b_nodeb'][0].ip),
                    'netmask': license_ip_info['ip_a_nodea'][0].netmask._prefix_from_ip_string(str(license_ip_info['ip_a_nodea'][0].netmask)),
                })
                failover_aliases.append({
                    'type': ip_type,
                    'address': str(license_ip_info['ip_b_nodea'][0].ip),
                    'netmask': license_ip_info['ip_a_nodea'][0].netmask._prefix_from_ip_string(str(license_ip_info['ip_a_nodea'][0].netmask)),
                })
                failover_virtual_aliases.append({
                    'type': ip_type,
                    'address': str(license_ip_info['ip_vip'][0].ip),
                    'netmask': license_ip_info['ip_vip'][0].netmask._prefix_from_ip_string(str(license_ip_info['ip_vip'][0].netmask)),
                })

            final_options['aliases'].append(aliases[0])
            final_options['failover_aliases'] = failover_aliases[0]
            final_options['failover_virtual_aliases'] = failover_virtual_aliases[0]
            final_options['failover_critical'] = license_ip_info['ip_crit']
            final_options['failover_group'] = license_ip_info['ip_grp']
            if not IS_LINUX:
                final_options['failover_vhid'] = license_ip_info['ip_vhid']

        # non HA config
        else:

            final_options = {
                'name': _int_name,
                'aliases': [{
                    'type': ip_type,
                    'address': str(non_license_ip_info['ip'][0].ip),
                    'netmask': non_license_ip_info['ip'][0].netmask._prefix_from_ip_string(str(non_license_ip_info['ip'][0].netmask)),
                }]
            }

        # finally send off the request to the API
        with Client() as c:
            c.call('interface.update', nic, final_options)
            c.call('service.start', 'network')
            print("Successfully changed interface settings.")
            return True
    except Exception as e:
        print("Failed saving interface configuration changes with error: \n%s", e)
        return False


def reset_root_pw(*args):
    print()
    print(_("Changing password for root"))
    print(_("This action will disable 2FA"))
    print()

    if not args:
        waituser = True

        def prompt(y):
            return (getpass.getpass(), getpass.getpass(y))

        while True:
            p1, p2 = prompt(_('Retype password: '))
            if p1 == p2:
                break
            print()
            print(_('Passwords do not match. Try again.'))
            print()
    else:
        p1 = args[0]
        waituser = False

    if p1:
        try:
            with Client() as c:
                user_id = c.call("user.query", [["username", "=", "root"]], {"get": True})["id"]
                c.call("user.update", user_id, {"password": p1})
                c.call("auth.twofactor.update", {"enabled": False})
        except (FileNotFoundError, ConnectionRefusedError):
            from middlewared.plugins.account import crypted_password
            conn = sqlite3.connect(FREENAS_DB)
            c = conn.cursor()
            c.execute("UPDATE account_bsdusers SET bsdusr_unixhash = ? WHERE bsdusr_username = 'root'",
                      (crypted_password(p1),))
            c.execute("UPDATE system_twofactorauthentication SET enabled = 0")
            conn.commit()
            conn.close()
        print()
        print(_('Password successfully changed.'))
        print()
    else:
        print()
        print(_('Password change aborted.'))
        print()

    if waituser:
        print(_('Press enter to continue'))
        print()
        input("")


def reset_factory_defaults(*args):
    a = input(
        _('The configuration will be erased and reset to defaults. Are you sure?') + '(yes/no): '
    )
    if a.lower().startswith('y'):
        try:
            with Client() as c:
                c.call('config.reset', {'reboot': False}, job=True)
            os.system("/sbin/shutdown -r now")
        except Exception as e:
            print("Failed to reset configuration: {}".format(str(e)))


def configure_lagg_interface(*args):

    lagg_menu = {
        '1': "Create Link Aggregation",
        '2': "Delete Link Aggregation",
        '3': "Quit",
    }
    for k, v in lagg_menu.items():
        print(f'{k}) {v}')

    create_lagg = delete_lagg = False
    while True:
        _input = input(f"\nEnter an option from 1-{len(lagg_menu)} (q to quit): ")
        if _input in lagg_menu.keys():
            if _input == '3':
                return False
            elif _input == '1':
                create_lagg = True
                break
            elif _input == '2':
                delete_lagg = True
                break
        else:
            print("Invalid option")
            continue

    # get our list of nics
    nics = get_nic_choices()

    # fbsd uses a different name than linux for "laggs"
    os_lagg_name = 'lagg' if not IS_LINUX else 'bond'

    # prep list of nics if creating lagg
    if create_lagg:
        exclude = []
        for i in nics:
            if i['type'] == 'LINK_AGGREGATION':
                exclude.append(i['id'])
                for j in i['lag_ports']:
                    exclude.append(j)
            elif i['type'] == 'VLAN':
                exclude.append(i['id'])

        # sort the nics
        choices = sorted([i['id'] for i in nics if i['id'] not in exclude])

        # something happend or all phys ints are being used by laggs
        if not choices:
            print("No interfaces available")
            return False

        # can't create a lagg with only 1 member interface
        if len(choices) == 1:
            print("lagg interfaces require at least 2 member interfaces")
            return False

        # prompt for member interfaces
        members = []
        while choices:
            for idx, nic in enumerate(choices, start=1):
                print(f"{idx}) {nic}")

            _parent_input = input("Select a member interface (q to quit): ")
            if _parent_input.lower().startswith("q") and not members:
                # means they quit before choosing any member interfaces
                return False
            elif _parent_input.lower().startswith("q") and len(members) >= 2:
                # assume they've chosen all the member interfaces they want
                break
            elif _parent_input.isdigit():
                _parent_input = int(_parent_input)
            else:
                print("Invalid option")
                continue

            if _parent_input in range(1, len(choices) + 1):
                members.append(choices[_parent_input - 1])
                choices.remove(choices[_parent_input - 1])
            else:
                print("Invalid option")
                continue

        # get lagg interface name
        while True:
            _lagg_name = input(f"Enter a {os_lagg_name} name {os_lagg_name}X where 'X' is a number (q to quit): ")
            if _lagg_name.lower().startswith('q'):
                return False
            elif not _lagg_name.lower().startswith(os_lagg_name):
                continue
            else:
                try:
                    int(_lagg_name.lower().split(os_lagg_name)[1])
                    break
                except Exception:
                    continue

        # get lagg protocol
        lagg_proto = None
        while True:
            for k, v in LAGGTypes.items():
                print(f'{k}) {v[1]}')

            _lagg_proto = input(f"Choose a {os_lagg_name} protocol (q to quit): ")
            if _lagg_proto.lower().startswith('q'):
                return False
            elif _lagg_proto.isdigit():
                if _lagg_proto == '1':
                    lagg_proto = LAGGTypes['1'][0]
                    break
                elif _lagg_proto == '2':
                    lagg_proto = LAGGTypes['2'][0]
                    break
                elif _lagg_proto == '3':
                    lagg_proto = LAGGTypes['3'][0]
                    break
                elif _lagg_proto == '4':
                    lagg_proto = LAGGTypes['4'][0]
                    break
                else:
                    print("Invalid option")
                    continue
            else:
                print("Invalid option")
                continue

        # get vlan description
        _lagg_desc = input(f"{os_lagg_name} description (enter for none): ")

        # send it off to the API
        print(f"Saving {os_lagg_name} interface")
        options = {
            'name': _lagg_name,
            'description': _lagg_desc,
            'type': 'LINK_AGGREGATION',
            'lag_protocol': lagg_proto,
            'lag_ports': members,
        }
        try:
            with Client() as c:
                c.call('interface.create', options)
                c.call('service.start', 'network')
                print(f"Successfully created {os_lagg_name}")
                return True
        except Exception as e:
            print(f"Failed creating {os_lagg_name} interface with error: \n%s", e)
            return False

    # prep list of nics if deleting lagg
    if delete_lagg:
        choices = [i['id'] for i in nics if i['id'].startswith(os_lagg_name)]
        # means no vlans are created so nothing to do
        if not choices:
            print(f"No {os_lagg_name} interfaces to delete")
            input("Press enter to return to main screen\n")
            return False

    while True:
        for idx, nic in enumerate(choices, start=1):
            print(f"{idx}) {nic}")

        _lagg_to_delete = input(f"Select a {os_lagg_name} to delete (q to quit): ")
        if _lagg_to_delete.lower().startswith("q"):
            return False
        elif _lagg_to_delete.isdigit():
            _lagg_to_delete = int(_lagg_to_delete)
        else:
            print("Invalid option")
            continue

        if _lagg_to_delete in range(1, len(choices) + 1):
            lagg_to_delete = choices[_lagg_to_delete - 1]
        else:
            print("Invalid option")
            continue

        # send it off to the API
        try:
            with Client() as c:
                c.call('interface.delete', lagg_to_delete)
                c.call('service.start', 'network')
                print(f"Successfully deleted {os_lagg_name}")
                return True
        except Exception as e:
            print(f"Failed deleting {os_lagg_name} interface with error: \n%s", e)
            return False


def configure_vlan(*args):

    vlan_menu = {
        '1': "Create VLAN Interface",
        '2': "Delete VLAN Interface",
        '3': "Quit",
    }
    for k, v in vlan_menu.items():
        print(f'{k}) {v}')

    create_vlan = delete_vlan = False
    while True:
        _input = input(f"\nEnter an option from 1-{len(vlan_menu)} (q to quit): ")
        if _input in vlan_menu.keys():
            if _input == '3':
                return False
            elif _input == '1':
                create_vlan = True
                break
            elif _input == '2':
                delete_vlan = True
                break
        else:
            print("Invalid option")
            continue

    # get our list of nics
    nics = get_nic_choices()

    # prep list of nics for creating vlan
    if create_vlan:
        exclude = []
        for i in nics:
            if i['type'] == 'LINK_AGGREGATION':
                for j in i['lag_ports']:
                    exclude.append(j)
            elif i['type'] == 'VLAN':
                exclude.append(i['id'])

        # sort the nics
        choices = sorted([i['id'] for i in nics if i['id'] not in exclude])

        # this shouldn't happen but check anyway
        if not choices:
            print("No parent interfaces detected")
            return False

        # prompt for vlan parent interface
        while True:
            for idx, nic in enumerate(choices, start=1):
                print(f"{idx}) {nic}")

            _parent_input = input("Select a parent interface (q to quit): ")
            if _parent_input.lower().startswith("q"):
                return False
            elif _parent_input.isdigit():
                _parent_input = int(_parent_input)
            else:
                print("Invalid option")
                continue

            if _parent_input in range(1, len(choices) + 1):
                parent_int = choices[_parent_input - 1]
                break
            else:
                print("Invalid option")
                continue

        # get vlan interface name
        while True:
            _vlan_name = input("Enter a vlan name vlanX where 'X' is a number (q to quit): ")
            if _vlan_name.lower().startswith('q'):
                return False
            elif not _vlan_name.lower().startswith('vlan'):
                continue
            else:
                try:
                    int(_vlan_name.lower().split('vlan')[1])
                    break
                except Exception:
                    continue

        # get vlan tag
        while True:
            _vlan_tag = input("Enter a vlan tag (q to quit): ")
            if _vlan_tag.lower().startswith('q'):
                return False
            elif _vlan_tag.isdigit():
                if int(_vlan_tag) < 1 or int(_vlan_tag) > 4094:
                    print("vlan tag must be between 1 and 4094")
                    continue
                else:
                    _vlan_tag = int(_vlan_tag)
                    break
            else:
                print("vlan tag must be an integer")
                continue

        # get vlan description
        _vlan_desc = input("vlan description (enter for none): ")

        # send it off to the API
        print("Saving vlan interface")
        options = {
            'name': _vlan_name,
            'description': _vlan_desc,
            'type': 'VLAN',
            'vlan_parent_interface': parent_int,
            'vlan_tag': _vlan_tag,
        }
        try:
            with Client() as c:
                c.call('interface.create', options)
                c.call('service.start', 'network')
                print("Successfully created vlan")
                return True
        except Exception as e:
            print("Failed creating vlan interface with error: \n%s", e)
            return False

    # prep list of nics if deleting vlan
    if delete_vlan:
        choices = [i['id'] for i in nics if i['id'].startswith('vlan')]
        # means no vlans are created so nothing to do
        if not choices:
            print("No vlan interfaces to delete")
            input("Press enter to return to main screen\n")
            return False

    while True:
        for idx, nic in enumerate(choices, start=1):
            print(f"{idx}) {nic}")

        _vlan_to_delete = input("Select a vlan to delete (q to quit): ")
        if _vlan_to_delete.lower().startswith("q"):
            return False
        elif _vlan_to_delete.isdigit():
            _vlan_to_delete = int(_vlan_to_delete)
        else:
            print("Invalid option")
            continue

        if _vlan_to_delete in range(1, len(choices) + 1):
            vlan_to_delete = choices[_vlan_to_delete - 1]
        else:
            print("Invalid option")
            continue

        # send it off to the API
        try:
            with Client() as c:
                c.call('interface.delete', vlan_to_delete)
                c.call('service.start', 'network')
                print("Successfully deleted vlan")
                return True
        except Exception as e:
            print("Failed deleting vlan interface with error: \n%s", e)
            return False


def configure_default_route(*args):

    route_menu = {
        '1': 'IPv4 default route',
        '2': 'IPv6 default route',
        '3': 'Quit',
    }
    ipv4 = ipv6 = False
    while True:
        for k, v in route_menu.items():
            print(f'{k}) {v}')

        _route_option = input(f"Choose an option between 1-{len(route_menu)}: ")
        if _route_option in route_menu.keys():
            if _route_option == '3':
                return False
            elif _route_option == '1':
                ipv4 = True
            elif _route_option == '2':
                ipv6 = True
            ip_addr = input('IP Address: ')

        else:
            print("Invalid option")
            continue

        try:
            if ipv4:
                def_gw = ipaddress.IPv4Interface(ip_addr)
                break
            elif ipv6:
                def_gw = ipaddress.IPv6Interface(ip_addr)
                break
        except (ipaddress.AddressValueError, ipaddress.NetmaskValueError):
            print('\nInvalid IP address')
            continue

    print("Updating default route")
    try:
        with Client() as c:
            c.call(
                'network.globalconfiguration.update',
                {'ipv4gateway' if ipv4 else 'ipv6gateway': str(def_gw.ip)}
            )
            c.call('route.sync')
            print('Successfully updated default route')
            return True
    except Exception as e:
        print("Failed to update default route with error: \n%s", e)
        return False


def configure_static_routes(*args):
    dest = input(_("Destination network: "))
    gateway = input(_("Gateway: "))
    desc = input(_("Description: "))

    try:
        ipaddr.IPNetwork(dest)
    except ValueError:
        print(_("Invalid destination network"))
        return False
    try:
        ipaddr.IPAddress(gateway)
    except ValueError:
        print(_("Invalid gateway"))
        return False

    sr = StaticRoute()
    sr.sr_destination = dest
    sr.sr_gateway = gateway
    if desc:
        sr.sr_description = desc
    print(_("Saving static route:"), end=' ')
    try:
        sr.save()
    except Exception:
        print(_("Failed"))
        return False
    print(_("ok"))
    try:
        print(_("Restarting routing:"), end=' ')
        with Client() as c:
            c.call('service.reload', 'networkgeneral')
    except Exception:
        print(_("Failed"))
        return False
    print(_("ok"))
    return True


def configure_dns(*args):
    ns1 = ns2 = ns3 = domain = None
    gc = GlobalConfiguration.objects.all()
    gc = gc[0]

    domain_prompt = prompt(_("DNS Domain"), gc.gc_domain)
    ns1_prompt = prompt(_("DNS Nameserver 1"), gc.gc_nameserver1)
    ns2_prompt = prompt(_("DNS Nameserver 2"), gc.gc_nameserver2)
    ns3_prompt = prompt(_("DNS Nameserver 3"), gc.gc_nameserver3)

    domain = input(domain_prompt)
    if domain:
        gc.gc_domain = domain

    need_save = False
    print(_("Enter nameserver IPs, an empty value ends input"))
    while True:
        ns1 = input(ns1_prompt)
        if ns1:
            try:
                ipaddr.IPAddress(ns1, version=4)
            except ValueError:
                print(_("Invalid nameserver"))
                return False
            gc.gc_nameserver1 = ns1
            need_save = True
            gc.gc_nameserver2 = ''
            gc.gc_nameserver3 = ''
        else:
            return False

        ns2 = input(ns2_prompt)
        if ns2:
            try:
                ipaddr.IPAddress(ns2, version=4)
            except ValueError:
                print(_("Invalid nameserver"))
                break
            gc.gc_nameserver2 = ns2
        else:
            break

        ns3 = input(ns3_prompt)
        if ns3:
            try:
                ipaddr.IPAddress(ns3, version=4)
            except ValueError:
                print(_("Invalid nameserver"))
                break
            gc.gc_nameserver3 = ns3
        break

    if need_save:
        print(_("Saving DNS configuration:"), end=' ')
        try:
            gc.save()
        except Exception:
            print(_("Failed"))
            return False
        print(_("ok"))

        print(_("Reloading network config:"), end=' ')
        try:
            with Client() as c:
                c.call('service.reload', 'networkgeneral')
        except Exception:
            print(_("Failed"))
            return False
        print(_("ok"))
        return True


def shell(*args):
    return os.system("/usr/bin/su -l root")


def automatic_ix_alert(*args):
    support = Support.objects.order_by('-id')[0]
    if support.enabled:
        text = _("enabled")
    else:
        text = _("disabled")
    print(_("Automatic support alerts to iXsystems: %s") % text)
    while True:
        if support.enabled:
            ret = input(_("Disable (y/n): "))
        else:
            ret = input(_("Enable (y/n): "))
        if ret.lower().startswith("y"):
            support.enabled = not support.enabled
            support.save()
            return True
        if ret.lower().startswith("n"):
            return False


def reboot(*args):
    while True:
        ret = input(_("Confirm reboot (y/n): "))
        if ret.lower().startswith("y"):
            os.system("/sbin/shutdown -r now")
            time.sleep(60)
            return False
        if ret.lower().startswith("n"):
            return False


def shutdown(*args):
    while True:
        ret = input(_("Confirm Shutdown (y/n): "))
        if ret.lower().startswith("y"):
            os.system(f"/sbin/shutdown -{'P' if IS_LINUX else 'p'} now")
            time.sleep(60)
            return False
        if ret.lower().startswith("n"):
            return False


def show_ip():
    with Client() as c:
        urls = c.call('system.general.get_ui_urls')

    if urls:
        print()
        print(_("The web user interface is at:"))
        print()

        for url in sorted(urls):
            print(url)
    else:
        print()
        print(_("The web interface could not be accessed."))
        print(_("Please check network configuration."))

    print()


def netcli_title():

    product = ''
    serial = ''
    version = ''

    try:
        with Client() as c:
            data = c.call('system.dmidecode_info')
            product = data['system-product-name']
            serial = data['system-serial-number']
            version = c.call('system.version') + ' | '
    except Exception:
        pass

    return f'{product} | {version}{serial}'


def main_menu():
    menu = [
        [_("Configure Network Interfaces"), configure_interface_stub],
        [_("Configure Link Aggregation"), configure_lagg_interface],
        [_("Configure VLAN Interface"), configure_vlan],
        [_("Configure Default Route"), configure_default_route],
        [_("Configure Static Routes"), configure_static_routes],
        [_("Configure DNS"), configure_dns],
        [_("Reset Root Password"), reset_root_pw],
        [_("Reset Configuration to Defaults"), reset_factory_defaults],
        [_("Shell"), shell],
        [_("Reboot"), reboot],
        [_("Shut Down"), shutdown],
    ]

    failover_status = 'SINGLE'
    try:
        with Client() as c:
            support_available = c.call('support.is_available')
            is_enterprise = c.call('system.is_enterprise')
            if is_enterprise:
                failover_status = c.call('failover.status')
    except Exception:
        support_available = False
        is_enterprise = False

    if is_enterprise and support_available:
        menu.insert(12, [_("Toggle automatic support alerts to iXsystems"), automatic_ix_alert])

    menu_map = {}
    menu_max = 0
    for item in menu:
        menu_max = menu_max + 1
        menu_map[menu_max] = item
        # If this was requested on the command line, then we just call it
        if len(sys.argv) > 1:
            if globals()[sys.argv[1]] == item[1]:
                item[1](*sys.argv[2:])
                sys.exit(0)

    while True:
        if is_enterprise and os.path.exists('/tmp/.failover_needop'):
            """
            Currently we can have multiple pools.
            Because one encrypted pool failed to import does not mean the node
            is supposed/allowed to unlock.
            """
            passphrase = (failover_status != 'MASTER')
            if passphrase:
                try:
                    with Client() as c:
                        passphrase &= (
                            c.call('failover.call_remote', 'failover.status') != 'MASTER'
                        )

                except Exception:
                    pass

            with open('/tmp/.failover_needop', 'r') as f:
                failed_pools = [p.strip() for p in f.read().strip().split('\n') if p.strip()]

            if passphrase and failed_pools:
                yes = input('Enter passphrase for pools which failed to decrypt ? (y/n)')
                if yes.lower().startswith('y'):
                    cache = []
                    for pool in failed_pools:
                        key = None
                        while not key:
                            try:
                                key = getpass.getpass(f'Please enter passphrase for "{pool}" pool: ')
                            except EOFError:
                                print('Please provide a valid key')
                            else:
                                if not key:
                                    print('Provided key is empty, please provide a valid key')
                        cache.append({'name': pool, 'passphrase': key})
                    print('Forcing current node to become MASTER')

                    with Client() as c:
                        c.call('failover.unlock', {'pools': cache})

                    time.sleep(5)
                    continue

        if is_enterprise:
            print(netcli_title())

        print()
        print(_("Console setup"))
        print("-------------")
        print()

        for index in menu_map:
            print("%d) %s" % (index, menu_map[index][0]))

        try:
            show_ip()
        except Exception:
            pass

        try:
            ch = int(input(_("Enter an option from 1-%d: ") % (menu_max)))
        except ValueError:
            ch = None
        if ch in menu_map:
            f = menu_map[ch][1]
            try:
                if f not in [reset_root_pw, reset_factory_defaults, shell, reboot, shutdown]:
                    ensure_failover_is_disabled()
                f()
            except FailoverIsEnabledException:
                print("You can't perform this action unless failover is administratively disabled")
                print("Press Enter to return to console")
                input()


# No signal handling here, it is assumed that this script
# will be setup in /etc/ttys, so we just exit ;-).
if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal.SIG_IGN)

    while True:
        try:
            try:
                with Client() as c:
                    console = c.call('system.advanced.config')['consolemenu']
            except Exception:
                console = True
            if console:
                main_menu()
            else:
                show_ip()
                if IS_LINUX:
                    proc = subprocess.Popen(['/usr/bin/tty'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    stdout, stderr = proc.communicate()
                    if proc.returncode:
                        print(f'Failed to determine active tty: {stderr.decode()}')
                        os.execv('/bin/login', ['/bin/login'])
                    else:
                        terminal = os.path.relpath(stdout.decode().strip(), '/dev')
                        os.execv('/sbin/agetty', ['/sbin/agetty', '--noclear', '--keep-baud', terminal])
                else:
                    os.execv('/usr/libexec/getty', ['/usr/libexec/getty', 'Pc'])
        except SystemExit as e:
            sys.exit(e.code)
        except Exception:
            traceback.print_exc()
            exit(1)
